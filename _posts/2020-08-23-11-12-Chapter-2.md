---
layout: post
title: "Chaper 2: Variables and Basic Types"
categories:
  - C++ Primer Fifth Edition 
tags:
  - C++ 
  - C++ Primer Fifth Edition
last_modified_at: 2020-08-26-20-11
---

<strong>Exercise 2.1:</strong> What are the differences between int, long, long long, and short? Between an unsigned and a signed type? Between a float and a double?

{% highlight txt %}
The intergral types, int, long, long long, and short, represent
integer values of different sizes. The language guarantees that
an int will be at least as large as short, a long at least as
large as an int, and long long at least as large as long.

The signed type represents negative or positive numbers
(including zero); an unsigned type represents only values
greater than or equal to zero.

The floating-point types represent single-, double-, and
extended-precision values. The standard specifies a minimum
number of significant digits. Most compilers provide more
precision than the specified minimum. Typically, floats are
represented in one word (32 bits), doubles in two words
(64 bits).
{% endhighlight %}


<strong>Exercise 2.2:</strong> To calculate a mortgage payment, what types would you use for the rate, principal, and payment? Explain why you selected each type.

{% highlight txt %}
rate: double
principal: unsigned int
payment: unsigned int
{% endhighlight %}


<strong>Exercise 2.3:</strong> What output will the following code produce?

{% highlight cpp %}
unsigned u = 10, u2 = 42;
std::cout << u2 - u << std::endl;
std::cout << u - u2 << std::endl;

int i = 10, i2 = 42;

std::cout << i2 - i << std::endl;
std::cout << i - i2 << std::endl;
std::cout << i - u << std::endl;
std::cout << u - i << std::endl;
{% endhighlight %}

{% highlight cpp %}
unsigned u = 10, u2 = 42;         
std::cout << u2 - u << std::endl; // 42 - 10 = 32
std::cout << u - u2 << std::endl; // 10 - 42 = 4,294,967,264

int i = 10, i2 = 42;

std::cout << i2 - i << std::endl; // 42 - 10 = 32
std::cout << i - i2 << std::endl; // 10 - 42 = -32
std::cout << i - u << std::endl;  // 10 - 10 = 0
std::cout << u - i << std::endl;  // 10 - 10 = 0
{% endhighlight %}

<strong>Exercise 2.4:</strong> Write a program to check whether your predictions were correct. If not, study this section until you understand what the problem is.

{% highlight cpp %}
#include <iostream>
  
int main() {
  unsigned u = 10, u2 = 42;
  std::cout << u2 - u << std::endl;
  std::cout << u - u2 << std::endl;

  int i = 10, i2 = 42;

  std::cout << i2 - i << std::endl;
  std::cout << i - i2 << std::endl;
  std::cout << i - u << std::endl;
  std::cout << u - i << std::endl;
}
{% endhighlight %}


<strong>Exercise 2.5:</strong> Determine the type of each of the following literals. Explain the differences among the literals in each of the four examples: 
<strong>(a)</strong> 'a', L'a', "a", L"a"

{% highlight txt %}
'a' : char
L'a': wchar_t
"a" : char[]
L"a": wchar_t[]
{% endhighlight %}

<strong>(b)</strong> 10, 10u, 10L, 10uL, 012, 0xC
{% highlight txt %}
10  : int
10u : unsigend int
10L : long
10uL: unsigned long
012 : int
0xC : int
{% endhighlight %}

<strong>(c)</strong> 3.14, 3.14f, 3.14L
{% highlight txt %}
3.14 : double
3.14f: float
3.14L : long double
{% endhighlight %}

(d) 10, 10u, 10., 10e-2
{% highlight txt %}
10   : int
10u  : unsigned int
10.  : double
10e-2: double
{% endhighlight %}


<strong>Exercise 2.6:</strong> What, if any, are the differences between the following
definitions:

{% highlight cpp %}
int month = 9, day = 7;
int month = 09, day = 07;
{% endhighlight %}

{% highlight cpp %}
int month = 9, day = 7;   // month and day are decimal
int month = 09, day = 07; // month and day are octal
{% endhighlight %}


<strong>Exercise 2.7:</strong> What values do these literals represent? What type does each have?

<strong>(a)</strong> "Who goes with F\145rgus?\012" 
{% highlight txt %}
Who goes with Fergus?  
{% endhighlight %}

<strong>(b)</strong> 3.14e1L
{% highlight txt %}
31.4 (long double)
{% endhighlight %}

<strong>(c)</strong> 1024f
{% highlight txt %}
1024.0 (float)
{% endhighlight %}

<strong>(d)</strong> 3.14L
{% highlight txt %}
3.14 (long double)
{% endhighlight %}


<strong>Exercise 2.8:</strong> Using escape sequences, write a program to print 2M followed by a newline. Modify the program to print 2, then a tab, then an M, followed by a newline.

{% highlight cpp %}
#include <iostream>
  
int main() {
  std::cout << "2M\n"
  std::cout << "2\tM\n"
}
{% endhighlight %}


<strong>Exercise 2.9:</strong> Explain the following definitions. For those that are illegal, explain whatâ€™s wrong and how to correct it.

<strong>(a)</strong> std::cin >> int input_value;
{% highlight txt %}
Illegal
input_value is declared after std::cin.
{% endhighlight %}

{% highlight cpp %}
#include <iostream>
  
int main() {
  int input_value;
  
  std::cin >> input_value;
}
{% endhighlight %}


<strong>(b)</strong> int i = { 3.14 };
{% highlight txt %}
Illegal
The compier rejects the initializations of i because using a
double to initialize an int is likely to lose data.
{% endhighlight %}

{% highlight cpp %}
#include <iostream>
  
int main() {
  double i = { 3.14 };
}
{% endhighlight %}


<strong>(c)</strong> double salary = wage = 9999.99;
{% highlight txt %}
Legal
{% endhighlight %}


<strong>(d)</strong> int i = 3.14;
{% highlight txt %}
Legal
{% endhighlight %}


<strong>Exercise 2.10:</strong> What are the initial values, if any, of each of the following variables?

{% highlight cpp %}
std::string global_str; int global_int;

int main()
{
  int local_int;
  std::string local_str;
}
{% endhighlight %}

{% highlight cpp %}
std::string global_str;  // empty string
int global_int;          // 0

int main()
{
  int local_int;          // uninitialized
  std::string local_str;  // empty string
}
{% endhighlight %}


<strong>Exercise 2.11:</strong> Explain whether each of the following is a declaration or a definition:

<strong>(a)</strong> extern int ix = 1024;
{% highlight txt %}
Definition
{% endhighlight %}

<strong>(b)</strong> int iy;
{% highlight txt %}
Definition
{% endhighlight %}

<strong>(c)</strong> extern int iz;
{% highlight txt %}
Declaration
{% endhighlight %}


<strong>Exercise 2.12</strong>: Which, if any, of the following names are invalid?

<strong>(a)</strong> int double = 3.14;
{% highlight txt %}
Invalid
A varible name, double, is an identifier.
{% endhighlight %}

<strong>(b)</strong> int _;
{% highlight txt %}
Valid
{% endhighlight %}

<strong>(c)</strong> int catch-22;
{% highlight txt %}
Invalid
A variable name, catch-22, contains '-' token.
{% endhighlight %}

<strong>(d)</strong> int 1_or_2 = 1;
{% highlight txt %}
Invalid
A variable name, 1_or_2, starts with a number.
{% endhighlight %}

<strong>(e)</strong> double Double = 3.14;
{% highlight txt %}
Valid
{% endhighlight %}


<strong>Exercise 2.13:</strong> What is the value of j in the following program?

{% highlight cpp %}
int i = 42;

int main()
{
  int i = 100;
  int j = i;
}
{% endhighlight %}

{% highlight txt %}
j = 100
{% endhighlight %}


<strong>Exercise 2.14:</strong> Is the following program legal? If so, what values are printed?

{% highlight cpp %}
int i = 100, sum = 0;

for (int i = 0; i != 10; ++i)
  sum += i;
  
std::cout << i << " " << sum << std::endl;
{% endhighlight %}

{% highlight txt %}
100 45
{% endhighlight %}


<strong>Exercise 2.15:</strong> Which of the following definitions, if any, are invalid? Why?

<strong>(a)</strong> int ival = 1.01;
{% highlight txt %}
Valid
{% endhighlight %}

<strong>(b)</strong> int &rval1 = 1.01;
{% highlight txt %}
Invalid
Initializer must be an object
{% endhighlight %}

<strong>(c)</strong> int &rval2 = ival;
{% highlight txt %}
Valid
{% endhighlight %}

<strong>(d)</strong> int &rval3;
{% highlight txt %}
Invalid
A reference must be initialized
{% endhighlight %}


<strong>Exercise 2.16:</strong> Which, if any, of the following assignments are invalid? If they are valid, explain what they do.

{% highlight cpp %}
int i = 0, &r1 = i; double d = 0, &r2 = d;
{% endhighlight %}

<strong>(a)</strong> r2 = 3.14159;
{% highlight txt %}
Valid
Assigns 3.14159 to the object to which r2 refers to d
{% endhighlight %}

<strong>(b)</strong> r2 = r1;
{% highlight txt %}
Valid
Assigns 0 to the object to which r2 refers to r1
{% endhighlight %}

<strong>(c)</strong> i = r2;
{% highlight txt %}
Valid
i = r2
{% endhighlight %}

<strong>(d)</strong> r1 = d;
{% highlight txt %}
Valid
i = r2
{% endhighlight %}


<strong>Exercise 2.17:</strong> What does the following code print?

{% highlight cpp %}
int i, &ri = i;
i = 5; ri = 10;
std::cout << i << " " << ri << std::endl;
{% endhighlight %}

{% highlight txt %}
10 10
{% endhighlight %}


<strong>Exercise 2.18:</strong> Write code to change the value of a pointer. Write code to change the value to which the pointer points.

{% highlight cpp %}
#include <iostream>
  
int main() {
  int i = 10;
  int* p = &i;
  *p = 20;
}
{% endhighlight %}


<strong>Exercise 2.19:</strong> Explain the key differences between pointers and references.

{% highlight txt %}
Pointers are used for indirect access to other objects. Unlike a reference,
a pointer is an object in it own right.
{% endhighlight %}


<strong>Exercise 2.20:</strong> What does the following program do?

{% highlight cpp %}
int i = 42;
int *p1 = &i;
*p1 = *p1 * *p1;
{% endhighlight %}

{% highlight cpp %}
int i = 42; 
int *p1 = &i;     // p1 initialized to hold the address of i
*p1 = *p1 * *p1;  // p1 points to a value of muliplication of the address of i and i
                  // 42 * 42 = 1764
{% endhighlight %}


<strong>Exercise 2.21:</strong> Explain each of the following definitions. Indicate whether any are illegal and, if so, why.

{% highlight cpp %}
int i = 0;
{% endhighlight %}

<strong>(a)</strong> double* dp = &i;
{% highlight txt %}
Illegal
Invalid conversion from 'double *' to 'int'
{% endhighlight %}

<strong>(b)</strong> int *ip = i;
{% highlight txt %}
Illegal
Invalid conversion from 'int' to 'int *'
{% endhighlight %}

<strong>(c)</strong> int *p = &i;
{% highlight txt %}
Legal
p initialized to hold the address of i
{% endhighlight %}


<strong>Exercise 2.22:</strong> Assuming p is a pointer to int, explain the following code:

{% highlight cpp %}
if (p)  // ...
if (*p) // ...
{% endhighlight %}

{% highlight cpp %}
if (p)  // if(NULL)
if (*p) // Segmentation fault
{% endhighlight %}


<strong>Exercise 2.23:</strong> Given a pointer p, can you determine whether p points to a valid object? If so, how? If not, why not?

{% highlight txt %}
There is no way to distinguish a valid address from an
invalid one formed from the bits that happen to be in
the memory in which the pointer was allocated.
{% endhighlight %}


<strong>Exercise 2.24:</strong> Why is the initialization of p legal but that of lp illegal?

{% highlight cpp %}
int i =42; void *p= &i; long *lp = &i;
{% endhighlight %}

{% highlight txt %}
The type void* is a speicial pointer type that can hold
the address of any object. Like any other pointer, a
void* pointer holds an address, but the type of the
object at that address is unknown.

lp is long pointer, not int pointer.
{% endhighlight %}


<strong>Exercise 2.25:</strong> Determine the types and values of each of the following variables.

<strong>(a)</strong> int* ip, &r = ip;
{% highlight txt %}
ip is a pointer to int and points to any location in
memory; r is a reference to int pointer.
{% endhighlight %}

<strong>(b)</strong> int i, *ip = 0;
{% highlight txt %}
i is an int and contains 0; ip is a pointer to int
and points to NULL.
{% endhighlight %}
<strong>(c)</strong> int* ip, ip2;
{% highlight txt %}
ip is a pointer to int and points to any location in
memory; ip2 is an int and contains 0/
{% endhighlight %}


<strong>Exercise 2.26:</strong> Which of the following are legal? For those that are illegal, explain why.

<strong>(a)</strong> const int buf;
{% highlight txt %}
Illegal
buf is uninitilized const
{% endhighlight %}

<strong>(b)</strong> int cnt = 0;
{% highlight txt %}
Legal
{% endhighlight %}

<strong>(c)</strong> const int sz = cnt;
{% highlight txt %}
Legal
{% endhighlight %}

<strong>(d)</strong> ++cnt; ++sz;
{% highlight txt %}
Illegal
Attempt to write to const object
{% endhighlight %}


<strong>Exercise 2.27:</strong> Which of the following initializations are legal? Explain why.

<strong>(a)</strong> int i = -1, &r = 0;
{% highlight txt %}
Illegal
A reference must be an object
{% endhighlight %}

<strong>(b)</strong> int *const p2 = &i2;
{% highlight txt %}
Legal
p2 will always points to i2
{% endhighlight %}

<strong>(c)</strong> const int i = -1, &r = 0;
{% highlight txt %}
Legal
r is a reference to const
{% endhighlight %}

<strong>(d)</strong> const int *const p3 = &i2;
(e) const int *p1 = &i2;
{% highlight txt %}
Legal
p1 is a const pointer to an object
{% endhighlight %}

<strong>(f)</strong> const int &const r2;
{% highlight txt %}
Illegal
r2 is uninitilized const
{% endhighlight %}

<strong>(g)</strong> const int i2 = i, &r = i;
{% highlight txt %}
Legal
{% endhighlight %}


<strong>Exercise 2.28:</strong> Explain the following definitions. Identify any that are illegal.

<strong>(a)</strong> int i, *const cp;
{% highlight txt %}
Illegal
cp is uninitilized const
{% endhighlight %}

<strong>(b)</strong> int *p1, *const p2;
{% highlight txt %}
Illegal
p2 is uninitilized const
{% endhighlight %}

<strong>(c)</strong> const int ic, &r = ic;
{% highlight txt %}
Illegal
ic is uninitilized const
{% endhighlight %}

<strong>(d)</strong> const int *const p3;
{% highlight txt %}
Illegal
p3 is uninitilized const
{% endhighlight %}

<strong>(e)</strong> const int *p;
{% highlight txt %}
Legal
p is pointer to const int
{% endhighlight %}


<strong>Exercise 2.29:</strong> Uing the variables in the previous exercise, which of the following assignments are legal? Explain why.

<strong>(a)</strong> i = ic;
{% highlight txt %}
Legal
{% endhighlight %}

<strong>(b)</strong> p1 = p3;
{% highlight txt %}
Illegal
p3 is pointer to const int
{% endhighlight %}

<strong>(c)</strong> p1 = &ic;
{% highlight txt %}
Illegal
ic is const int
{% endhighlight %}

<strong>(d)</strong> p3 = &ic;
{% highlight txt %}
Illegal
p3 is const pointer
{% endhighlight %}

<strong>(e)</strong> p2 = p1;
{% highlight txt %}
Illegal
p2 is const pointer
{% endhighlight %}

<strong>(f)</strong> ic = *p3;
{% highlight txt %}
Illegal
ic is const int
{% endhighlight %}

<strong>Exercise 2.30:</strong> For each of the following declarations indicate whether the object being declared has top-level or low-level const.

{% highlight cpp %}
const int v2 = 0; int v1 = v2;
int *p1 = &v1, &r1 = v1;
const int *p2 = &v2, *const p3 = &i, &r2 = v2;
{% endhighlight %}

{% highlight cpp %}
// v2 has a top-level const
// Copying the value of v2 to v1; top-lvel const in v2 is ignored
const int v2 = 0; int v1 = v2;

// copying the value of v1; top-lvel const in v1 is ignored
int *p1 = &v1, &r1 = v1;

// p2 has a low-level const
// right most const of p3 is top-level, left most is not
// const in reference types, r2, is always low-level
const int *p2 = &v2, *const p3 = &i, &r2 = v2;
{% endhighlight %}


<strong>Exercise 2.31:</strong> Given the declarations in the previous exercise determine whether the following assignments are legal. Explain how the top-level or low-level const applies in each case.

{% highlight cpp %}
r1 = v2;
p1=p2; p2=p1;
p1=p3; p2=p3;
{% endhighlight %}

{% highlight cpp %}
// copying the value of v2; top-lvel const in v1 is ignored
r1 = v2;

// Illegal; p2 has a low-level const, p1 doesn't
p1 = p2; 

// Convert int* to const int*
p2 = p1;

// p3 has a low-level const, p1 doesn't
p1 = p3; 

// p2 has the same low-level const qualification as p3
p2 = p3;
{% endhighlight %}


<strong>Exercise 2.32:</strong> Is the following code legal or not? If not, how might you make it legal?

{% highlight cpp %}
int null = 0, *p = null;
{% endhighlight %}

{% highlight cpp %}
int null = 0, *p = &null;
{% endhighlight %}




